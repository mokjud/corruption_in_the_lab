---
title: "Corruption in the lab"
author: "Fedor Anna, Mokos Judit"
#date: "19/12/2018"
#output: pdf_document
output: word_document
#output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
rm(list=ls())
N=10 # number of participants in the dummy data
set.seed(1)

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(rmarkdown)
library(dplyr)
library(ggplot2)
library(knitr)
```

# Description of the experiment
    
Sequential dyadic die-rolling task  
Two-by-two design:
    
* Game: simple game or charity game
* Partner: simulated honest partner or simulated dishonest partner  

Participants are randomly assigned to one of the four conditions:

* SH: simple game with honest partner
* SD: simple game with dishonest partner
* CH: charity game with honest partner
* CD: charity game with dishonest partner  

Each participant plays 20 rounds of the game. A round of game consists of the following steps:

1. Participant learns the reported number of the supposed partner
2. Participant throws a dice
3. Participant reports the number 
4. Both players get a score according to the reported numbers: the score is the reported value, if they reported a double; otherwise it's 0
5. In the charity game a charity foundation gets a small amount of donation  

# Dummy data

Data frame column names (each row is a dice roll):

* ID: random ID of participant (10000:99999)
* Game: simple or charity (S/C)
* Partner: honest or dishonest (H/D)
* Condition: one of the four experimental conditions (SH, SD, CH, CD)
* Index: index of round of game (1:20)
* ValueA: value of simulated dice roll (1:6)
* ValueB: value of participant's reported dice roll (1:6)
* Double: whether the participant reported a double (1/0)
* Q1: answer to first questionnaire quiestion (a random letter)
* Q2: answer to second questionnaire question (a random letter)
* Fingerratio: ratio of two fingers (normal distribution, mean=1, sd=0.1)

```{r Generate dummy data}

IDs <- sample(10000:99999, N)
games <- sample(c("S", "C"), N, replace=TRUE)
partners <- sample(c("H", "D"), N, replace=TRUE)
conditions = paste(games, partners, sep="")

A_honest <- sample(1:6, 20, replace=TRUE)
A_dishonest <- sample(4:6, 20, replace=TRUE)

ValueAs <- vector("integer", N*20)
for (i in 1:N) {
  if (partners[i] == "H") {ValueAs[((i-1)*20+1) : ((i-1)*20+20)] <- A_honest}
  if (partners[i] == "D") {ValueAs[((i-1)*20+1) : ((i-1)*20+20)] <- A_dishonest}
}

fingerratios <- rnorm(N, mean = 1, sd = 0.1)

rawdata <- data.frame(
  ID = rep(IDs, times = 1, length.out = NA, each = 20), 
  Game = rep(games, times = 1, length.out = NA, each = 20), 
  Partner = rep(partners, times = 1, length.out = NA, each = 20), 
  Condition = rep(conditions, times = 1, length.out = NA, each = 20),
  Index = rep(1:20, N), 
  ValueA = ValueAs, 
  ValueB = sample(1:6, N*20, replace = TRUE), 
  Double = vector("logical", N*20),
  Q1 = sample(letters, N*20, replace = TRUE), 
  Q2 = sample(letters, N*20, replace = TRUE),
  Fingerratio = rep(fingerratios, times = 1, length.out = NA, each = 20))

rawdata <- mutate(rawdata, Double = ifelse(ValueA==ValueB, TRUE, FALSE))

```
# Data checking

* Check if every participant had 20 round
    + Delete participants who had less than 20 rounds
    + Delete excess rounds for each participant
* Check if there is any missing data (columns)  

```{r Data checking}
```

# Figures

## Scatter plots of individual behavior
These should be based on Weisel & Shalvi, 2015, Fig. S10.  
One plot per participant. Plots from the same condition should be compiled into one composite figure.  

```{r Scatter plots}

person <- as.factor(unique(rawdata$ID)) 

for(i in person){
  #yourfilename=paste("figure1_", i, ".jpg",sep="") #filename for sacing
  #jpeg(file=yourfilename)

  figure1 <- ggplot(data=filter(rawdata, ID==i), aes(x=Index))+
    geom_point(aes(y=ValueA), shape=1, size=5)+
    geom_point(aes( y=ValueB), shape=3, size=2)+
    theme_classic()+
    scale_x_continuous(name="Period")+
    scale_y_continuous(name="Report")+
    ggtitle(paste("subject's ID:", i ))
  
  #cat(" subject's ID:",  paste(i), "  \n")  
  print(figure1)
  #dev.off() 
  cat("  \n")

}
```

## Heat map to demonstrate the distribution of reported numbers 
Like Weisel & Shalvi, 2015, Fig. 2, but instead of circles, each rectangle should be color coded according the number of observations within them.  
One figure per condition.  

```{r Heat maps}

cond <- as.factor(unique(rawdata$Condition))
maximum <- max(count(rawdata, ValueA, ValueB, Condition)$n)

for(i in cond){
  heatmap_df <- data.frame(count(filter(rawdata, Condition==i), ValueA, ValueB))
  
  #yourfilename=paste("figure2_", i, ".jpg",sep="") #filename for sacing
  #jpeg(file=yourfilename)
  
  figure2 <- ggplot(data=heatmap_df, aes(x=ValueA, y=ValueB))+
      geom_tile(aes(fill=n))+
      theme_classic()+
      scale_x_continuous(breaks=c(1:6), limits=c(0,7))+
      scale_y_continuous(breaks=c(1:6), limits=c(0,7))+
      scale_fill_gradient(low = "#F0F0F0", high = "black", na.value="white", limits=c(1, maximum), breaks=c(1:maximum), labels=c(1:maximum))+
      ggtitle(paste("condition", i ))
  #cat("  \n Condition:",  paste(i), "  \n")  
  print(figure2)
  #dev.off()
  cat("  \n")
}

```

## Box plots of the mean number of doubles
One box for each condition on the same figure  
(Mean reports: does not make sense in our case, because player A is simulated)  

```{r Box plots}

cond <- as.factor(unique(rawdata$Condition))
number.of.doubles <-  count(filter(rawdata, Double==TRUE), ID, Condition)
 
 figure3 <- ggplot(data= number.of.doubles, aes(y=n, group=Condition))+
   geom_boxplot()+
   theme_minimal()+
   scale_x_continuous(breaks=c(-0.3, -0.1, 0.1, 0.3), labels=c(as.character(cond)), name="conditions")+
   scale_y_continuous(name='number of doubles per 20 rounds')
 
 #yourfilename=paste("figure3", ".jpg",sep="") #filename for sacing
 #jpeg(file=yourfilename)
 print(figure3)
 #dev.off()

```

# Statistics

## Summary of data

Summary of groups:  
```{r Create useful variables from raw data}

participants <- rawdata %>%
  group_by(ID) %>%
  summarize(
    Condition = unique(Condition), 
    Nbof_doubles = sum(Double), 
    Avg_report = mean(ValueB))

groups <- participants %>%
  group_by(Condition) %>%
  summarize(
    Nbof_participants = n_distinct(ID),
    Nbof_doubles = sum(Nbof_doubles),
    Avg_nbof_doubles = Nbof_doubles/Nbof_participants,
    Avg_avg_report = mean(Avg_report))

kable(groups)


```

Summary of participants:  

```{r Create useful variables from raw data 2.0}

kable(head(participants))

```

## Distribution of reported numbers 

Our null hypothesis is that the reported values come from a uniform distribution, i.e. numbers from 1 to 6 are reported with the same probability, since we used a fair dice. Our alternative hypothesis is that participants cheat and report doubles in order to inflate their profit.  

This would lead to skewed distributions when the participant playes with a dishonest simulated partner who reports larger numbers with higher probability. In case of an honest simulated partner, whose dice throw values were sampled from a uniform distribution, we expect that the participants' reported values also come from a uniform ditribution (although it is possible that participants try to signal to their supposed partners to cheat by occassionally reporting 6s, but we do not expect this to create a significant difference).

We used chi-square goodness of fit tests to test whether the reported values come from a uniform distribution, separately for each condition.

```{r chi-square JUDIT}

probabilities <- c(rep(1/6, 6))

df.results <- data.frame(condition=cond, df=NA, chi.square=NA, p_value=NA)
for(i in cond)
{
  reported_B <- count(filter(rawdata, Condition==i), ValueB)$n
  results <- chisq.test(reported_B, p=probabilities, simulate.p.value = TRUE)
  
  df.results[which(df.results$condition==i), ]$df <- results$parameter
  df.results[which(df.results$condition==i), ]$chi.square <- results$statistic
   df.results[which(df.results$condition==i), ]$p_value <- results$p.value
  
  #cat("  \n Condition:",  paste(i), "  \n") 
  #print(results)
}

kable(df.results, digits=2)

```

We decided not to use Kolmogorov-Smirnov, despite that it has been used previously by others (Gachter, Schulz, 2016). The large number of ties in our sample makes this test unreliable.
  
We also made qqplots:  
_HOW TO MAKE THE PLOTS SQUARE?_

```{r qqplots ANNA}


honestvalues <- rep(1:6, 10000)
honestvalues_cdf <- ecdf(1:5)

for(i in cond)
{
  group_data <- filter(rawdata, Condition == i)
  par(pty="s")
  qqplot(group_data$ValueB, honestvalues, 
         main= paste("Condition:", i, ", Q-Q Plot"),
         xlab="reported values",
         ylab= "honest values")
  
  #cat("  \n Condition:",  paste(i), "  \n") 
  #print(figure_qqplot)
}

```

## The number of doubles
Ultimately, participants must report doubles, thus match their reported values to that of player A, in order to increase their payoff. The chi-square test cannot detect cheating in those groups where player A is "honest", even if player B cheats on each and every round, because the distribution of reported values would still come from a uniform distribution. Testing the mean of the reported numbers against an expected value of 3.5 does not make sense for the same reasons.
Therefore, we also tested, whether the number of doubles is higher than its expected value of 3.33 (the probability of throwing a double is 1/6; the expected number of doubles in 20 rounds is 20*1/6 = 3.33 in case of a fair dice and honest player).

Each participant ("dyad") is a single observation: the number of reported doubles  
Wilcoxon signed-rank U test, separately for each condition  
Expected value: 3.33 doubles/20 trials (16.7%; 20*1/6)  

```{r Wilcoxon signed-rank U test}

w <- list()
for (i in groups$Condition) {
  #print(i)
  current <- filter(participants, Condition == i)
  w[[i]] <- wilcox.test(current$Nbof_doubles, 3.33, alternative = "greater", conf.int = TRUE)
  #print(w)
}
result.wilcox.table <- data.frame(condition=groups$Condition,
                                  p.value=c(w[[1]]$p.value, w[[2]]$p.value, w[[3]]$p.value, w[[4]]$p.value),
                                  W= c(w[[1]]$statistic, w[[2]]$statistic, w[[3]]$statistic, w[[4]]$statistic))
kable(result.wilcox.table, digits=3)


```

## Compare the number of doubles in pairs of conditions
Mann-Whitney U test (or two-sample Wilcoxon test), one-sided.  

The effect of dishonest partners vs honest partners in the simple game and in the charity game:
```{r Mann-Whitney U test 1}

w1 <- wilcox.test(filter(participants, Condition=="SH")$Nbof_doubles, filter(participants, Condition=="SD")$Nbof_doubles, conf.int = TRUE, alternative = "less" )
w2 <- wilcox.test(filter(participants, Condition=="CH")$Nbof_doubles, filter(participants, Condition=="CD")$Nbof_doubles, conf.int = TRUE, alternative = "less" )
results.wilcox.table <- data.frame(compare=c("SH-SD", "CH-CD"),
                                   p.value= c(w1$p.value, w2$p.value),
                                   W= c(w1$statistic, w2$statistic))
kable(results.wilcox.table, digits=3)

```

The effect of charity vs no charity with honest partner and with dishonest partner:
```{r Mann-Whitney U test 2}


w1 <- wilcox.test(filter(participants, Condition=="SH")$Nbof_doubles, filter(participants, Condition=="CH")$Nbof_doubles, conf.int = TRUE, alternative = "less" )
w2 <- wilcox.test(filter(participants, Condition=="SD")$Nbof_doubles, filter(participants, Condition=="CD")$Nbof_doubles, conf.int = TRUE, alternative = "less" )
results.wilcox.table <- data.frame(compare=c("SH-CH", "SD-CD"),
                                   p.value= c(w1$p.value, w2$p.value),
                                   W= c(w1$statistic, w2$statistic))
kable(results.wilcox.table, digits=3)


#wilcox.test(participants_group_SH$Nbof_doubles, participants_group_CH$Nbof_doubles, conf.int = TRUE, alternative = "less")
#wilcox.test(participants_group_SD$Nbof_doubles, participants_group_CD$Nbof_doubles, conf.int = TRUE, alternative = "less")
```

## Effect size (ANNA)
To estimate the effect size of the honest-dishonest treatment let's compare the choices of participant Bs, who were paired with an honest A vs. a cheating A.  
Data: from the supplementary material of Weisel&Shalvy, 2015 and from Wouda et al., 2015  
The number of doubles in each condition against the hypothetical expected value: Wilcoxon signed-rank U test
expected value = 3.33
maximum value when cheating = 20

Compare the number of doubles in pairs of conditions: Wilcoxon signed-rank U test 


Monte Carlo method
One can simulate the distribution you think the two samples come from many thousands of times using Monte Carlo methods. The percentage of those samples the Wilcoxon test correctly identifies as "different" is the power of the test. For example, if you generated 10,000 different simulated paired samples that match your actual data in terms of size and the distribution they came from, and 8,000 of them are correctly identified by the test as different, your power = 0.80.

```{r}


```

## Linear regression to test the effect of predictors (JUDIT)
Dependent variable: number of reported doubles (interval)  
Predictors: game (binary), partner (binary), fingerratio (interval)

```{r}
participants2 <- rawdata %>%
  group_by(ID) %>%
  summarize(
    Game = unique(Game), 
    Nbof_doubles = sum(Double), 
    Avg_report = mean(ValueB),
    Partner = unique(Partner),
    Fingerratio = unique(Fingerratio))

model1 <- lm(Nbof_doubles ~ Game + Partner + Fingerratio, data=participants2 )
summary1 <- summary(model1)
kable(summary1$coefficients, digits=3)
```

Residual standard error: `r round(summary1$sigma, 3)`  
Multiple R-squared: `r round(summary1$r.squared, 3)`  
Adjusted R-squared: `r round(summary1$adj.r.squared, 3)`  
F-statistic: `r round(summary1$fstatistic[[1]], 3)`  



